import React from 'react';
import AppHeader from './AppHeader';
import CartItem from './CartItem';
import { useTelegramWebApp } from '../hooks/useTelegramWebApp';
import { CartItemData } from '../App';
import { useLockBodyScroll } from '../hooks/useLockBodyScroll';
import { createOrder, OrderRequest, fetchUserInfo } from '../api/client';

interface CartProps {
  cartItems: CartItemData[];
  onOpenMenu: () => void;
  selectedAddress: string;
  onOpenStoreAddresses: () => void;
  deliveryMethod: 'pickup' | 'delivery';
  setDeliveryMethod: (method: 'pickup' | 'delivery') => void;
  onIncreaseQuantity: (productId: number) => void;
  onDecreaseQuantity: (productId: number) => void;
  onRemoveItem: (productId: number) => void;
  onClearCart: () => void;
}

const Cart: React.FC<CartProps> = ({
  cartItems,
  onOpenMenu,
  selectedAddress,
  onOpenStoreAddresses,
  deliveryMethod,
  setDeliveryMethod,
  onIncreaseQuantity,
  onDecreaseQuantity,
  onRemoveItem,
  onClearCart
}) => {
  const { webApp, user } = useTelegramWebApp();
  const [customAddress, setCustomAddress] = React.useState('');
  const [isSubmitting, setIsSubmitting] = React.useState(false);

  useLockBodyScroll(true);

  // Рассчитываем общую сумму всех товаров
  const totalPrice = cartItems.reduce((sum, item) => {
    const basePrice = parseFloat(item.product.price.replace(/[^\d]/g, ''));
    return sum + (basePrice * item.quantity);
  }, 0);

  const handleDecrease = (productId: number) => {
    onDecreaseQuantity(productId);
    webApp?.HapticFeedback.impactOccurred('light');
  };

  const handleIncrease = (productId: number) => {
    onIncreaseQuantity(productId);
    webApp?.HapticFeedback.impactOccurred('light');
  };

  const handleRemove = (productId: number) => {
    onRemoveItem(productId);
    webApp?.HapticFeedback.notificationOccurred('warning');
  };

  const handleBuy = async () => {
    if (cartItems.length === 0) return;
    if (isSubmitting) return;

    // Валидация адреса доставки
    if (deliveryMethod === 'delivery' && !customAddress.trim()) {
      webApp?.HapticFeedback.notificationOccurred('error');
      webApp?.showAlert('Пожалуйста, введите адрес доставки');
      return;
    }

    // Проверяем наличие user
    if (!user) {
      webApp?.HapticFeedback.notificationOccurred('error');
      webApp?.showAlert('Ошибка: не удалось получить данные пользователя');
      return;
    }

    setIsSubmitting(true);
    webApp?.HapticFeedback.notificationOccurred('success');

    try {
      // Получаем initData для авторизации
      const initData = webApp?.initData || '';

      // Проверяем наличие контактных данных пользователя
      let userInfo = await fetchUserInfo(initData);
      
      // Если нет phone - запрашиваем телефон
      if (!userInfo.phone) {
        setIsSubmitting(false);
        
        // Показываем информационное сообщение
        const shouldRequestContact = await new Promise<boolean>((resolve) => {
          webApp?.showConfirm(
            'Для оформления заказа нам нужен ваш номер телефона. Поделиться контактом?',
            (confirmed) => resolve(confirmed)
          );
        });

        if (!shouldRequestContact) {
          webApp?.showAlert('Без контактных данных мы не сможем связаться с вами для оформления заказа');
          return;
        }

        // Запрашиваем контакт пользователя через Telegram
        if (webApp?.requestContact) {
          webApp.requestContact();
          
          // Показываем сообщение с инструкцией
          webApp?.showAlert(
            'Сейчас откроется чат с ботом. Пожалуйста, поделитесь своим контактом, нажав на кнопку.',
            async () => {
              // После закрытия alert начинаем проверять обновление данных
              let attempts = 0;
              const maxAttempts = 15; // 15 попыток * 1 секунду = 15 секунд
              
              const checkInterval = setInterval(async () => {
                attempts++;
                
                try {
                  // Проверяем, сохранился ли телефон
                  const updatedUserInfo = await fetchUserInfo(initData);
                  
                  if (updatedUserInfo.phone) {
                    clearInterval(checkInterval);
                    webApp?.showAlert(
                      '✅ Номер телефона получен! Теперь нажмите "Заказать" еще раз для оформления заказа.',
                      () => {
                        webApp?.HapticFeedback.notificationOccurred('success');
                      }
                    );
                  } else if (attempts >= maxAttempts) {
                    clearInterval(checkInterval);
                    webApp?.showAlert(
                      'Не удалось получить номер телефона. Пожалуйста, убедитесь, что вы поделились своим контактом в чате с ботом, затем нажмите "Заказать" еще раз.'
                    );
                  }
                } catch (error) {
                  console.error('Failed to check updated user info:', error);
                  if (attempts >= maxAttempts) {
                    clearInterval(checkInterval);
                  }
                }
              }, 1000); // Проверяем каждую секунду
            }
          );
        } else {
          webApp?.showAlert('Ваш Telegram не поддерживает запрос контакта. Обновите приложение.');
        }
        return;
      }
      // Определяем тип доставки и адрес
      const delivery_type = deliveryMethod === 'pickup' ? 'PICK_UP' : 'COURIER';
      const delivery_address = deliveryMethod === 'pickup' ? selectedAddress : customAddress.trim();

      // Формируем данные заказа для бэкенда
      const orderRequest: OrderRequest = {
        status: 'NEW',
        user_id: user.id,
        delivery_type,
        delivery_address,
        cart_items: cartItems.map(item => ({
          good_id: item.product.id,
          count: item.quantity,
        })),
      };

      // Отправляем заказ на бэкенд
      const createdOrder = await createOrder(orderRequest, initData);

      console.log('Order created successfully:', createdOrder);

      // Отправляем данные боту для уведомления (опционально, для обратной совместимости)
      const botData = {
        order_id: createdOrder.id,
        user: {
          id: user.id,
          first_name: user.first_name,
          last_name: user.last_name,
          username: user.username,
        },
        items: cartItems.map(item => ({
          id: item.product.id,
          title: item.product.title,
          price: parseFloat(item.product.price.replace(/[^\d]/g, '')),
          quantity: item.quantity,
        })),
        totalPrice,
        deliveryMethod: deliveryMethod === 'pickup' ? 'Самовывоз' : 'Курьером',
        address: delivery_address,
        timestamp: new Date().toISOString(),
      };

      if (webApp) {
        webApp.sendData(JSON.stringify(botData));
      }

      // Показываем сообщение об успехе
      webApp?.showAlert('Заказ успешно оформлен!');

      // Очищаем корзину после успешной покупки
      onClearCart();
    } catch (error) {
      console.error('Failed to create order:', error);
      webApp?.HapticFeedback.notificationOccurred('error');
      webApp?.showAlert(`Ошибка при создании заказа: ${error instanceof Error ? error.message : 'Неизвестная ошибка'}`);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="fixed inset-0 bg-white z-50 max-w-[402px] mx-auto overflow-y-auto">
      <div className="min-h-full">
        <AppHeader
          title="FanFanTulpan"
          actionType="menu-text"
          onAction={onOpenMenu}
        />
        <div className="p-8 pt-6">
        {/* Cart Items */}
        {cartItems.length === 0 ? (
          <div className="text-center py-10">
            <p className="text-lg font-medium text-[#A09CAB]">Ваша корзина пока пуста</p>
          </div>
        ) : (
          cartItems.map((item) => {
            const itemTotalPrice = parseFloat(item.product.price.replace(/[^\d]/g, '')) * item.quantity;
            return (
              <CartItem
                key={item.product.id}
                product={item.product}
                quantity={item.quantity}
                totalPrice={itemTotalPrice}
                onDecrease={() => handleDecrease(item.product.id)}
                onIncrease={() => handleIncrease(item.product.id)}
                onRemove={() => handleRemove(item.product.id)}
              />
            );
          })
        )}

        {/* Delivery Method */}
        <div className="mb-6">
          <h3 className="text-base font-bold leading-[1.174] text-black mb-4">
            Способ получение
          </h3>
          <div className="relative h-10 bg-[#D9D9D9] rounded-[10px] overflow-hidden">
            <div
              className={`absolute top-0 h-full w-1/2 bg-[#80D1C1] rounded-[10px] transition-transform duration-300 ${
                deliveryMethod === 'delivery' ? 'translate-x-full' : 'translate-x-0'
              }`}
            />
            <div className="relative h-full flex">
              <button
                onClick={() => {
                  setDeliveryMethod('pickup');
                  webApp?.HapticFeedback.selectionChanged();
                }}
                className="flex-1 text-base font-medium leading-[1.174] text-black"
              >
                Самовывоз
              </button>
              <button
                onClick={() => {
                  setDeliveryMethod('delivery');
                  webApp?.HapticFeedback.selectionChanged();
                }}
                className="flex-1 text-base font-medium leading-[1.174] text-black"
              >
                Курьером
              </button>
            </div>
          </div>
        </div>

        {/* Address */}
        {deliveryMethod === 'pickup' ? (
          <div className="flex items-center gap-3 mb-8">
            <svg width="40" height="40" viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg" className="w-10 h-10">
              <g clipPath="url(#clip0_location)">
                <path d="M20 20C20.55 20 21.0208 19.8042 21.4125 19.4125C21.8042 19.0208 22 18.55 22 18C22 17.45 21.8042 16.9792 21.4125 16.5875C21.0208 16.1958 20.55 16 20 16C19.45 16 18.9792 16.1958 18.5875 16.5875C18.1958 16.9792 18 17.45 18 18C18 18.55 18.1958 19.0208 18.5875 19.4125C18.9792 19.8042 19.45 20 20 20ZM20 27.35C22.0333 25.4833 23.5417 23.7875 24.525 22.2625C25.5083 20.7375 26 19.3833 26 18.2C26 16.3833 25.4208 14.8958 24.2625 13.7375C23.1042 12.5792 21.6833 12 20 12C18.3167 12 16.8958 12.5792 15.7375 13.7375C14.5792 14.8958 14 16.3833 14 18.2C14 19.3833 14.4917 20.7375 15.475 22.2625C16.4583 23.7875 17.9667 25.4833 20 27.35ZM20 30C17.3167 27.7167 15.3125 25.5958 13.9875 23.6375C12.6625 21.6792 12 19.8667 12 18.2C12 15.7 12.8042 13.7083 14.4125 12.225C16.0208 10.7417 17.8833 10 20 10C22.1167 10 23.9792 10.7417 25.5875 12.225C27.1958 13.7083 28 15.7 28 18.2C28 19.8667 27.3375 21.6792 26.0125 23.6375C24.6875 25.5958 22.6833 27.7167 20 30Z" fill="#49454F"/>
              </g>
              <defs>
                <clipPath id="clip0_location">
                  <rect width="40" height="40" rx="20" fill="white"/>
                </clipPath>
              </defs>
            </svg>
            <p className="text-base font-semibold leading-[1.174] text-black flex-1">
              {selectedAddress}
            </p>
            <button
              onClick={onOpenStoreAddresses}
              className="text-base font-semibold leading-[1.174] text-black hover:opacity-70 transition-opacity"
            >
              Выбрать
            </button>
          </div>
        ) : (
          <div className="mb-8">
            <input
              type="text"
              value={customAddress}
              onChange={(e) => setCustomAddress(e.target.value)}
              placeholder="Введите адрес доставки"
              className="w-full h-[53px] px-4 rounded-[15px] shadow-[0px_2px_4px_0px_rgba(0,0,0,0.25)] text-base font-semibold leading-[1.174] text-black bg-white"
            />
          </div>
        )}

        {/* Buy Button */}
        <button
          onClick={handleBuy}
          disabled={cartItems.length === 0 || isSubmitting}
          className={`w-full h-[66px] rounded-[30px] shadow-[0px_4px_4px_0px_rgba(0,0,0,0.25)] flex items-center justify-center ${
            cartItems.length > 0 && !isSubmitting ? 'bg-[#80D1C1]' : 'bg-gray-300'
          }`}
        >
          <span className="text-xl font-medium leading-[1.174] text-black">
            {isSubmitting ? 'Оформление...' : 'Заказать'}
          </span>
        </button>
        </div>
      </div>
    </div>
  );
};

export default Cart;
